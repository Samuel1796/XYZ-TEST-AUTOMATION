# CI pipeline for XYZ Bank Selenium UI tests: run on push to master or manual dispatch.
# Produces Allure report, publishes to GitHub Pages, optionally sends email (when SEND_EMAIL variable is true).
name: CI - Selenium UI Tests

on:
  push:
    branches:
      - master
  workflow_dispatch:

jobs:
  ui-tests-xyz-bank:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required for peaceiris/actions-gh-pages to push to gh-pages

    steps:
      # --- Source and environment ---
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Java 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"
          cache: maven

      # Log the app URL under test (value comes from repo secret APP_BASE_URL)
      - name: Print target URL
        run: 'echo "Testing URL: ${{ secrets.APP_BASE_URL }}"'

      # Download Chrome and ChromeDriver of the same version so Selenium works; set CHROME_BIN for headless
      - name: Install Chrome and ChromeDriver (matching versions)
        run: |
          set -e
          CHROME_JSON="https://googlechromelabs.github.io/chrome-for-testing/last-known-good-versions-with-downloads.json"
          CHROME_VERSION=$(curl -sS "$CHROME_JSON" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['channels']['Stable']['version'])")
          echo "Chrome/ChromeDriver version: $CHROME_VERSION"
          BASE="https://storage.googleapis.com/chrome-for-testing-public/$CHROME_VERSION/linux64"
          cd /tmp
          curl -sSLO "$BASE/chrome-linux64.zip"
          curl -sSLO "$BASE/chromedriver-linux64.zip"
          unzip -o chrome-linux64.zip
          unzip -o chromedriver-linux64.zip
          sudo mv chrome-linux64 /opt/chrome-for-testing
          sudo mv chromedriver-linux64/chromedriver /usr/local/bin/chromedriver
          sudo chmod +x /usr/local/bin/chromedriver
          echo "CHROME_BIN=/opt/chrome-for-testing/chrome" >> $GITHUB_ENV
          echo "/opt/chrome-for-testing/chrome" >> $GITHUB_PATH
          /opt/chrome-for-testing/chrome --version
          chromedriver --version

      # Run all tests; pass base URL and Allure executor props so report shows CI build and link to GitHub Pages
      - name: Run Selenium tests
        env:
          CHROME_BIN: ${{ env.CHROME_BIN }}
        run: |
          mvn -B -e test \
            -Dheadless.mode=true \
            -Dbase.url=${{ secrets.APP_BASE_URL }} \
            -DtrimStackTrace=false \
            -Dallure.executor.url=${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }} \
            -Dallure.executor.reportUrl=https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/ \
            -Dallure.executor.buildName="CI #${{ github.run_number }} ${{ github.ref_name }}" \
            -Dallure.executor.buildOrder=${{ github.run_number }}

      # Parse Surefire XML and print human-readable summary; exit 1 if any failures/errors (so job fails)
      - name: Test summary (Readable logs)
        if: always()
        run: |
          python3 - <<'PY'
          import glob, xml.etree.ElementTree as ET, sys, re
          files = glob.glob("target/surefire-reports/TEST-*.xml")
          total = failed = errors = skipped = 0
          failed_tests = []
          if not files:
            print("No Surefire XML reports found in target/surefire-reports.")
            sys.exit(1)
          for f in files:
            root = ET.parse(f).getroot()
            total += int(root.attrib.get("tests", 0))
            failed += int(root.attrib.get("failures", 0))
            errors += int(root.attrib.get("errors", 0))
            skipped += int(root.attrib.get("skipped", 0))
            for tc in root.findall("testcase"):
              name = tc.attrib.get("name", "unknown")
              for node in (tc.find("failure"), tc.find("error")):
                if node is not None:
                  msg = (node.attrib.get("message") or "").strip()
                  msg = msg.replace("failures)", "reasons)")
                  msg = re.sub(r'org\.opentest4j\.AssertionFailedError: ', '', msg)
                  short = "\n".join(msg.splitlines()[:6])
                  if len(msg.splitlines()) > 6:
                    short += "\n  ..."
                  failed_tests.append((name, short))
          passed = total - failed - errors - skipped
          icon = "✅" if (failed == 0 and errors == 0) else "❌"
          print("==================================")
          print(f"SELENIUM UI TEST SUMMARY {icon}")
          print("==================================")
          print(f"Total: {total} | Passed: {passed} | Failed: {failed} | Errors: {errors} | Skipped: {skipped}")
          if failed_tests:
            print("Failed:")
            for (name, reason) in failed_tests[:15]:
              print(f"  - {name}")
              print("    " + reason.replace("\n", "\n    "))
          print("==================================")
          if failed > 0 or errors > 0:
            sys.exit(1)
          PY

      # Build slack_payload.json and email_body.txt from same Surefire data for notifications
      - name: Build Slack payload and email body
        if: always()
        run: |
          python3 - <<'PY'
          import glob, json, xml.etree.ElementTree as ET, os, re
          files = glob.glob("target/surefire-reports/TEST-*.xml")
          total = failed = errors = skipped = 0
          failed_items = []
          repo = os.environ.get("GITHUB_REPOSITORY", "")
          branch = os.environ.get("GITHUB_REF_NAME", "")
          run_url = f"{os.environ.get('GITHUB_SERVER_URL')}/{repo}/actions/runs/{os.environ.get('GITHUB_RUN_ID')}"
          if not files:
            with open("slack_payload.json", "w", encoding="utf-8") as out:
              json.dump({"text": f"*Selenium UI Tests: FAIL*\nNo test reports.\nRun: {run_url}"}, out)
            with open("email_body.txt", "w", encoding="utf-8") as out:
              out.write(f"Selenium UI Tests: FAIL\nNo test reports.\nRun: {run_url}")
            raise SystemExit(0)
          for fpath in files:
            root = ET.parse(fpath).getroot()
            total += int(root.attrib.get("tests", 0))
            failed += int(root.attrib.get("failures", 0))
            errors += int(root.attrib.get("errors", 0))
            skipped += int(root.attrib.get("skipped", 0))
            for tc in root.findall("testcase"):
              name = tc.attrib.get("name", "unknown")
              for node in (tc.find("failure"), tc.find("error")):
                if node is not None:
                  msg = (node.attrib.get("message") or "").strip()
                  msg = re.sub(r'org\.opentest4j\.AssertionFailedError: ', '', msg)
                  short = "\n".join(msg.splitlines()[:6])
                  failed_items.append((name, short))
          passed = total - failed - errors - skipped
          status = "PASS ✅" if (failed == 0 and errors == 0) else "FAIL ❌"
          lines = [
            f"*Selenium UI Tests: {status}*",
            f"Total: *{total}* | Passed: *{passed}* | Failed: *{failed}* | Errors: *{errors}* | Skipped: *{skipped}*",
            "", f"Repo: `{repo}` | Branch: `{branch}`", f"Run: {run_url}"
          ]
          if failed_items:
            lines.insert(2, "*Failed:*")
            for (name, reason) in failed_items[:12]:
              lines.append(f"• *{name}*")
              lines.append(f"  {reason}")
          with open("slack_payload.json", "w", encoding="utf-8") as f:
            json.dump({"text": "\n".join(lines)}, f)
          email_lines = [
            f"Selenium UI Tests: {status}",
            f"Total: {total} | Passed: {passed} | Failed: {failed} | Errors: {errors} | Skipped: {skipped}",
            "", f"Repo: {repo} | Branch: {branch}", f"Run: {run_url}"
          ]
          if failed_items:
            email_lines.insert(2, "Failed:")
            for (name, reason) in failed_items[:12]:
              email_lines.append(f"- {name}: {reason}")
          with open("email_body.txt", "w", encoding="utf-8") as f:
            f.write("\n".join(email_lines))
          PY

      # Optional: send to Slack if SLACK_WEBHOOK_URL secret is set; continue-on-error so missing secret does not fail job
      - name: Notify Slack
        if: always()
        continue-on-error: true
        uses: slackapi/slack-github-action@v1.27.0
        with:
          payload-file-path: slack_payload.json
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      # Send email only when repo variable SEND_EMAIL is 'true' (vars.* used because secrets cannot be used in 'if')
      - name: Send Email report
        if: always() && vars.SEND_EMAIL == 'true'
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.SMTP_SERVER }}
          server_port: ${{ secrets.SMTP_PORT }}
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}
          subject: Selenium UI Tests - ${{ job.status == 'success' && 'PASS' || 'FAIL' }} - ${{ github.repository }} - ${{ github.ref_name }}
          to: ${{ secrets.EMAIL_TO }}
          from: ${{ secrets.SMTP_USERNAME }}
          secure: false
          body: file://email_body.txt

      # Debug: list and print Surefire .txt outputs when the test step failed
      - name: Print Surefire reports (on failure)
        if: failure()
        run: |
          ls -la target/surefire-reports || true
          for f in target/surefire-reports/*.txt; do [ -f "$f" ] && cat "$f";           done

      # Persist Surefire artifacts for download from Actions run
      - name: Upload Surefire test reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: surefire-reports
          path: target/surefire-reports/

      # Checkout gh-pages into gh-pages/ to copy existing Allure history (trends, history widget)
      - name: Load test report history
        if: always()
        uses: actions/checkout@v4
        with:
          ref: gh-pages
          path: gh-pages
        continue-on-error: true  # First run or if gh-pages does not exist yet

      # Merge previous report's history into this run's results so the new report shows trends
      - name: Copy history to allure-results
        if: always()
        run: |
          mkdir -p target/allure-results/history
          if [ -d "gh-pages/history" ]; then
            cp -r gh-pages/history/* target/allure-results/history/ 2>/dev/null || true
          fi

      # Fail fast if no Allure result/container JSON (e.g. tests did not run or Surefire misconfigured)
      - name: Verify Allure results before building report
        if: always()
        run: |
          if [ ! -d "target/allure-results" ]; then
            echo "::error::target/allure-results not found."
            exit 1
          fi
          N_RESULT=$(find target/allure-results -maxdepth 1 -type f -name "*-result.json" 2>/dev/null | wc -l)
          N_CONTAINER=$(find target/allure-results -maxdepth 1 -type f -name "*-container.json" 2>/dev/null | wc -l)
          N=$((N_RESULT + N_CONTAINER))
          if [ "$N" -eq 0 ]; then
            echo "::error::No Allure result/container JSON in target/allure-results."
            ls -la target/allure-results
            exit 1
          fi
          echo "Allure results: $N file(s)."

      # Generate the HTML report from target/allure-results (includes history we copied)
      - name: Build Allure Report
        if: always()
        run: mvn allure:report

      # Copy report from target/allure-report or target/site/allure-maven-plugin into a single dir for publishing
      - name: Prepare report for GitHub Pages
        if: always()
        run: |
          mkdir -p allure-report-with-history
          if [ -d "target/allure-report" ]; then
            cp -r target/allure-report/* allure-report-with-history/
            [ -d "target/allure-report/history" ] && cp -r target/allure-report/history allure-report-with-history/
          elif [ -d "target/site/allure-maven-plugin" ]; then
            cp -r target/site/allure-maven-plugin/* allure-report-with-history/
            [ -d "target/site/allure-maven-plugin/history" ] && cp -r target/site/allure-maven-plugin/history allure-report-with-history/
          else
            echo "::error::No Allure report directory found."
            exit 1
          fi

      # Rewrite report assets so they work when served at https://<owner>.github.io/<repo>/ (add base href and path prefix)
      - name: Patch Allure report for GitHub Pages subpath
        if: always()
        run: |
          REPO_NAME="${{ github.event.repository.name }}"
          D="allure-report-with-history"
          INDEX="$D/index.html"
          if [ ! -f "$INDEX" ]; then
            echo "No index.html to patch."
            exit 0
          fi
          sed -i 's|<head[^>]*>|&<base href="/'"$REPO_NAME"'/">|' "$INDEX"
          for path in data plugins styles history widgets config; do
            for ext in js html; do
              find "$D" -type f -name "*.$ext" | while read -r f; do
                sed -i "s|\"/${path}/|\"/${REPO_NAME}/${path}/|g; s|'/${path}/|'/${REPO_NAME}/${path}/|g; s|\"/${path}\"|\"/${REPO_NAME}/${path}\"|g" "$f"
              done
            done
          done
          echo "Patched for base path /$REPO_NAME/"

      # Push allure-report-with-history to gh-pages branch; GitHub serves it at <owner>.github.io/<repo>/
      - name: Publish Allure Report to GitHub Pages
        if: always()
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_branch: gh-pages
          publish_dir: allure-report-with-history
